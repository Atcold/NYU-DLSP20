---
lang-ref: ch.05-1
title: Optimizasyon Yöntemleri 1
lecturer: Aaron Defazio
authors: Vaibhav Gupta, Himani Shah, Gowri Addepalli, Lakshmi Addepalli
date: 24 Feb 2020
translation date: 17 July 2020
translator: melikenurm
---


## [Gradyan inişi](https://www.youtube.com/watch?v=--NZb480zlg&t=88s)

Optimizasyon Yöntemleri dersine bir çok yöntem içinde en basit ve en kötü(neden olduğundan bahsedeceğiz) yöntem olan Gradyan İnişi ile başlayacağız.

**Problem:**

$$
\min_w f(w)
$$

**Tekrarlamalı Çözüm:**

$$
w_{k+1} = w_k - \gamma_k \nabla f(w_k)
$$

burada,
 - $k$-ıncı tekrardan sonra güncellenmiş değer $w_{k+1}$,
 - $k$-ıncı tekrardan önceki başlangıç değeri $w_k$,
 - $\gamma_k$ adım miktarı,
 - $\nabla f(w_k)$ ise $f$'in gradyanı.

Burada $f$ fonksiyonunun sürekli ve türevlenebilir olduğu varsayılmaktadır. Amacımız optimizasyon fonksiyonunun en düşük noktasını(vadi) bulmaktır. Ancak, bu vadiye giden kesin yön bilinmemektedir. Yalnız bölgesel olarak bakılınca negatif gradyanın yönü sahip olduğumuz en iyi bilgidir. Ancak bu yönde küçük bir adım atmak bizi minimuma yaklaştırır. Bir kez küçük bir adım attıktan sonra, tekrar yeni gradyanı hesaplarız ve tekrar bu yönde küçük bir miktar hareket ederiz, ta ki vadiye ulaşıncaya kadar. Aslında temel olarak gradyan inişinin yaptığı şey en dik iniş(negatif gradyan) yönünü takip etmektir.

Tekrarmalı güncelleme denklemindeki $\gamma$ parametresine **adım miktarı** denir. Genelde en uygun adım boyutunun değeri bilinmez; bu yüzden farklı değerler denemek zorunda kalırız. Standart uygulama, bir log-ölçeğinde bir grup değeri denemek ve en iyisini kullanmaktır. Bu durumda oluşabilecek birkaç farklı senaryo vardır. Yukarıdaki görüntü 1 boyutlu ikinci dereceden(quadratic) bir fonksiyon için bu senaryoları göstermektedir. Öğrenme oranı çok düşük olursa minimum seviyeye doğru istikrarlı bir ilerleme kaydedebiliriz. Ancak bu ideal olandan daha fazla zaman alabilir. Bizi doğrudan minimuma indirecek bir adım boyutu elde etmek genellikle çok zordur (veya imkansızdır). Bu durumda ideal olarak isteyeceğimiz şey, optimalden biraz daha büyük bir adım boyutudur.  Pratikte bu en hızlı yakınsamayı sağlar. Bununla birlikte çok büyük bir öğrenme oranı kullanırsak tekrarlamalar sonunda minimumdan uzaklaşırız. Dolayısıyla uygulamada bizi saptıracak değerden biraz daha düşük bir öğrenme oranı kullanmak isteriz.
<center>
<img src="{{site.baseurl}}/images/week05/05-1/step-size.png" style="zoom: 70%; background-color:#DCDCDC;" /><br>
<b>Şekil 1:</b> 1 boyutlu ikinci dereceden fonksiyon için adım miktarları
</center>


## [Stokastik gradyan inişi](https://www.youtube.com/watch?v=--NZb480zlg&t=898s)

Stokastik gradyan inişinde gerçek gradyan vektörünü stokastik bir tahmini ile değiştiriyoruz. Özellikle bir sinir ağı için, stokastik tahmin tek bir veri noktasının (tek örnek) kaybının gradyanı anlamına gelir.

$i$-inci örnek için ağın kaybını $f_i$ ile gösterelim.

$$
f_i = l(x_i, y_i, w)
$$

Nihai olarak en aza indirmek istediğimiz fonksiyon, tüm örneklerin toplam kaybı olan $f$ 'dir.

$$
f = \frac{1}{n}\sum_i^n f_i
$$

SGD'de, $f_i$ üzerindeki gradyana(toplam kayıp $f$'in gradyanını kullanmak yerine) göre ağırlıkları güncelliyoruz. 

$$
\begin{aligned}
w_{k+1} &= w_k - \gamma_k \nabla f_i(w_k) & \quad\text{(i chosen uniformly at random)}
\end{aligned}
$$

Eğer $i$ rastgele seçilirse, $f_i$, $f$'in gürültülü ama tarafsız bir tahminleyicisidir ve matematiksel olarak şu şekilde yazılır:

$$
\mathbb{E}[\nabla f_i(w_k)] = \nabla f(w_k)
$$

Bunun sonucu olarak, SGD'nin beklenen $k$-ıncı adımı, tam gradyan inişin $k$-ıncı adımı ile aynıdır:

$$
\mathbb{E}[w_{k+1}] = w_k - \gamma_k \mathbb{E}[\nabla f_i(w_k)] = w_k - \gamma_k \nabla f(w_k)
$$

Bu nedenle, herhangi bir SGD güncellemesi, beklentide tam-toplu(full-batch) güncelleme ile aynıdır. Ancak, SGD sadece gürültülü ve daha hızlı gradyan inişi değildir. Daha hızlı olmanın yanı sıra, SGD bize tam-toplu gradyan inişten daha iyi sonuçlar verebilir. SGD'deki gürültü sığ yerel minimumlardan kaçınmak ve daha iyi (daha derin) bir minimum bulmak için yardımcı olabilir. Bu olaya **tavlama** denir.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/annealing.png"/><br>
<b>Şekil 2:</b> SGD'de tavlama
</center>

Özet olarak, Stokastik Gradyan İnişinin avantajları aşağıdaki gibidir:

 1. Örnekler arasında çok fazla gereksiz bilgi vardır. SGD bu gereksiz hesaplamaların çoğunu önler.
 2. Erken aşamalarda gürültü, gradyandaki bilgilere kıyasla küçüktür. Bu nedenle, bir SGD adımı *neredeyse* bir GD adımı kadar iyidir.
 3. *Tavlama* - SGD güncellemesindeki gürültü, kötü (sığ) bir yerel minimumda yakınsamayı önleyebilir.
 4. Stokastik Gradyan İnişini hesaplamak büyük ölçüde daha ucuzdur (tüm veri noktalarının üzerinden geçmediğiniz için).

### Mini-gruplama

Mini gruplamada, tek bir örnek üzerinden hesaplamak yerine, rastgele seçilmiş birden çok örnek üzerindeki kaybı dikkate alırız. Bu adım güncellemesinde oluşan gürültüyü azaltır.

$$
w_{k+1} = w_k - \gamma_k \frac{1}{|B_i|} \sum_{j \in B_i}\nabla f_j(w_k)
$$

Genellikle tek bir örnek yerine mini gruplar oluşturarak donanımımızı daha iyi kullanabiliriz. Örneğin, tek örnekli eğitim kullandığımızda GPU'lardan yetersiz faydalanılmaktadır. Dağıtılmış(distributed) ağlar için sunulan eğitim teknikleri, büyük bir mini grubu bir makine kümesine paylaştırır ve sonra ortaya çıkan gradyanları toplar. Facebook yakın zamanda dağıtılmış eğitim yöntemlerini kullanarak bir saat içinde ImageNet verileri ile bir ağ eğitmiştir.

Gradyan İnişin tam boyutlu gruplar ile hiçbir zaman kullanılmaması gerektiğini belirtmek önemlidir. Tam toplu boyutunda eğitim yapmak istiyorsanız, LBFGS adlı bir optimizasyon tekniğini kullanırız. PyTorch ve SciPy'da bu tekniğin uygulamaları bulunmaktadır.

## [Momentum](https://www.youtube.com/watch?v=--NZb480zlg&t=1672s)

In Momentum, we have two iterates ($p$ and $w$) instead of just one. The updates are as follows:

$$
\begin{aligned}
p_{k+1} &= \hat{\beta_k}p_k + \nabla f_i(w_k) \\
w_{k+1} &=  w_k - \gamma_kp_{k+1} \\
\end{aligned}
$$

$p$ is called the SGD momentum. At each update step we add the stochastic gradient to the old value of the momentum, after dampening it by a factor $\beta$ (value between 0 and 1). $p$ can be thought of as a running average of the gradients. Finally we move $w$ in the direction of the new momentum $p$.

Alternate Form: Stochastic Heavy Ball Method

$$
\begin{aligned}
w_{k+1} &= w_k - \gamma_k\nabla f_i(w_k) + \beta_k(w_k - w_{k-1}) & 0 \leq \beta < 1
\end{aligned}
$$

This form is mathematically equivalent to the previous form. Here, the next step is a combination of previous step's direction ($w_k - w_{k-1}$) and the new negative gradient.


### Intuition

SGD Momentum is similar to the concept of momentum in physics. The optimization process resembles a heavy ball rolling down the hill. Momentum keeps the ball moving in the same direction that it is already moving in. Gradient can be thought of as a force pushing the ball in some other direction.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/momentum.png"/><br>
<b>Figure 3:</b> Effect of Momentum<br>
<b>Source:</b><a href="https://distill.pub/2017/momentum/" target="_blank"> distill.pub </a><br>
</center>

Rather than making dramatic changes in the direction of travel (as in the figure on the left), momentum makes modest changes. Momentum dampens the oscillations which are common when we use only SGD.

The $\beta$ parameter is called the Dampening Factor. $\beta$ has to be greater than zero, because if it is equal to zero, you are just doing gradient descent. It also has to be less than 1, otherwise everything will blow up. Smaller values of $\beta$ result in change in direction quicker. For larger values, it takes longer to make turns.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/momentum-beta.png" style="zoom: 40%; background-color:#DCDCDC;"/><br>
<b>Figure 4:</b> Effect of Beta on Convergence
</center>


### Practical guidelines

Momentum must pretty much be always be used with stochastic gradient descent.
$\beta$ = 0.9 or 0.99 almost always works well.

The step size parameter usually needs to be decreased when the momentum parameter is increased to maintain convergence. If $\beta$ changes from 0.9 to 0.99, learning rate must be decreased by a factor of 10.


### Why does momentum works?


#### Acceleration

The following are the update rules for Nesterov's momentum.

$$
p_{k+1} = \hat{\beta_k}p_k + \nabla f_i(w_k) \\
w_{k+1} =  w_k - \gamma_k(\nabla f_i(w_k) +\hat{\beta_k}p_{k+1})
$$

With Nesterov's Momentum, you can get accelerated convergence if you choose the constants very carefully. But this applies only to convex problems and not to Neural Networks.

Many people say that normal momentum is also an accelerated method. But in reality, it is accelerated only for quadratics. Also, acceleration does not work well with SGD, as SGD has noise and acceleration does not work well with noise. Therefore, though some bit of acceleration is present with Momentum SGD, it alone is not a good explanation for the high performance of the technique.


#### Noise smoothing

Probably a more practical and probable reason to why momentum works is Noise Smoothing.

Momentum averages gradients. It is a running average of gradients that we use for each step update.

Theoretically, for SGD to work we should take average over all step updates.

$$
\bar w_k = \frac{1}{K} \sum_{k=1}^K w_k
$$

The great thing about SGD with momentum is that this averaging is no longer necessary. Momentum adds smoothing to the optimization process, which makes each update a good approximation to the solution. With SGD you would want to average a whole bunch of updates and then take a step in that direction.

Both Acceleration and Noise smoothing contribute to high performance of momentum.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/sgd-vs-momentum.png" style="zoom: 35%; background-color:#DCDCDC;"/><br>
<b>Figure 5:</b> SGD vs Momentum
</center>

With SGD, we make good progress towards solution initially but when we reach bowl (bottom of the valley) we bounce around in this floor. If we adjust learning rate we will bounce around slower. With momentum we smooth out the steps, so that there is no bouncing around.
