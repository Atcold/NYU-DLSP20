---
lang-ref: ch.05-1
title: Optimizasyon Yöntemleri 1
lecturer: Aaron Defazio
authors: Vaibhav Gupta, Himani Shah, Gowri Addepalli, Lakshmi Addepalli
date: 24 Feb 2020
translation date: 17 July 2020
translator: melikenurm
---


## [Gradyan inişi](https://www.youtube.com/watch?v=--NZb480zlg&t=88s)

Optimizasyon Yöntemleri dersine bir çok yöntem içinde en basit ve en kötü(neden olduğundan bahsedeceğiz) yöntem olan Gradyan İnişi ile başlayacağız.

**Problem:**

$$
\min_w f(w)
$$

**Tekrarlamalı Çözüm:**

$$
w_{k+1} = w_k - \gamma_k \nabla f(w_k)
$$

burada,
 - $k$-ıncı tekrardan sonra güncellenmiş değer $w_{k+1}$,
 - $k$-ıncı tekrardan önceki başlangıç değeri $w_k$,
 - $\gamma_k$ adım miktarı,
 - $\nabla f(w_k)$ ise $f$'in gradyanı.

Burada $f$ fonksiyonunun sürekli ve türevlenebilir olduğu varsayılmaktadır. Amacımız optimizasyon fonksiyonunun en düşük noktasını(vadi) bulmaktır. Ancak, bu vadiye giden kesin yön bilinmemektedir. Yalnız bölgesel olarak bakılınca negatif gradyanın yönü sahip olduğumuz en iyi bilgidir. Ancak bu yönde küçük bir adım atmak bizi minimuma yaklaştırır. Bir kez küçük bir adım attıktan sonra, tekrar yeni gradyanı hesaplarız ve tekrar bu yönde küçük bir miktar hareket ederiz, ta ki vadiye ulaşıncaya kadar. Aslında temel olarak gradyan inişinin yaptığı şey en dik iniş(negatif gradyan) yönünü takip etmektir.

Tekrarmalı güncelleme denklemindeki $\gamma$ parametresine **adım miktarı** denir. Genelde en uygun adım boyutunun değeri bilinmez; bu yüzden farklı değerler denemek zorunda kalırız. Standart uygulama, bir log-ölçeğinde bir grup değeri denemek ve en iyisini kullanmaktır. Bu durumda oluşabilecek birkaç farklı senaryo vardır. Yukarıdaki görüntü 1 boyutlu ikinci dereceden(quadratic) bir fonksiyon için bu senaryoları göstermektedir. Öğrenme oranı çok düşük olursa minimum seviyeye doğru istikrarlı bir ilerleme kaydedebiliriz. Ancak bu ideal olandan daha fazla zaman alabilir. Bizi doğrudan minimuma indirecek bir adım boyutu elde etmek genellikle çok zordur (veya imkansızdır). Bu durumda ideal olarak isteyeceğimiz şey, optimalden biraz daha büyük bir adım boyutudur.  Pratikte bu en hızlı yakınsamayı sağlar. Bununla birlikte çok büyük bir öğrenme oranı kullanırsak tekrarlamalar sonunda minimumdan uzaklaşırız. Dolayısıyla uygulamada bizi saptıracak değerden biraz daha düşük bir öğrenme oranı kullanmak isteriz.
<center>
<img src="{{site.baseurl}}/images/week05/05-1/step-size.png" style="zoom: 70%; background-color:#DCDCDC;" /><br>
<b>Şekil 1:</b> 1 boyutlu ikinci dereceden fonksiyon için adım miktarları
</center>


## [Stokastik gradyan inişi](https://www.youtube.com/watch?v=--NZb480zlg&t=898s)

Stokastik gradyan inişinde gerçek gradyan vektörünü stokastik bir tahmini ile değiştiriyoruz. Özellikle bir sinir ağı için, stokastik tahmin tek bir veri noktasının (tek örnek) kaybının gradyanı anlamına gelir.

$i$-inci örnek için ağın kaybını $f_i$ ile gösterelim.

$$
f_i = l(x_i, y_i, w)
$$

Nihai olarak en aza indirmek istediğimiz fonksiyon, tüm örneklerin toplam kaybı olan $f$ 'dir.

$$
f = \frac{1}{n}\sum_i^n f_i
$$

SGD'de, $f_i$ üzerindeki gradyana(toplam kayıp $f$'in gradyanını kullanmak yerine) göre ağırlıkları güncelliyoruz. 

$$
\begin{aligned}
w_{k+1} &= w_k - \gamma_k \nabla f_i(w_k) & \quad\text{(i chosen uniformly at random)}
\end{aligned}
$$

Eğer $i$ rastgele seçilirse, $f_i$, $f$'in gürültülü ama tarafsız bir tahminleyicisidir ve matematiksel olarak şu şekilde yazılır:

$$
\mathbb{E}[\nabla f_i(w_k)] = \nabla f(w_k)
$$

Bunun sonucu olarak, SGD'nin beklenen $k$-ıncı adımı, tam gradyan inişin $k$-ıncı adımı ile aynıdır:

$$
\mathbb{E}[w_{k+1}] = w_k - \gamma_k \mathbb{E}[\nabla f_i(w_k)] = w_k - \gamma_k \nabla f(w_k)
$$

Bu nedenle, herhangi bir SGD güncellemesi, beklentide tam-toplu(full-batch) güncelleme ile aynıdır. Ancak, SGD sadece gürültülü ve daha hızlı gradyan inişi değildir. Daha hızlı olmanın yanı sıra, SGD bize tam-toplu gradyan inişten daha iyi sonuçlar verebilir. SGD'deki gürültü sığ yerel minimumlardan kaçınmak ve daha iyi (daha derin) bir minimum bulmak için yardımcı olabilir. Bu olaya **tavlama** denir.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/annealing.png"/><br>
<b>Şekil 2:</b> SGD'de tavlama
</center>

Özet olarak, Stokastik Gradyan İnişinin avantajları aşağıdaki gibidir:

 1. Örnekler arasında çok fazla gereksiz bilgi vardır. SGD bu gereksiz hesaplamaların çoğunu önler.
 2. Erken aşamalarda gürültü, gradyandaki bilgilere kıyasla küçüktür. Bu nedenle, bir SGD adımı *neredeyse* bir GD adımı kadar iyidir.
 3. *Tavlama* - SGD güncellemesindeki gürültü, kötü (sığ) bir yerel minimumda yakınsamayı önleyebilir.
 4. Stokastik Gradyan İnişini hesaplamak büyük ölçüde daha ucuzdur (tüm veri noktalarının üzerinden geçmediğiniz için).

### Mini-gruplama

Mini gruplamada, tek bir örnek üzerinden hesaplamak yerine, rastgele seçilmiş birden çok örnek üzerindeki kaybı dikkate alırız. Bu adım güncellemesinde oluşan gürültüyü azaltır.

$$
w_{k+1} = w_k - \gamma_k \frac{1}{|B_i|} \sum_{j \in B_i}\nabla f_j(w_k)
$$

Genellikle tek bir örnek yerine mini gruplar oluşturarak donanımımızı daha iyi kullanabiliriz. Örneğin, tek örnekli eğitim kullandığımızda GPU'lardan yetersiz faydalanılmaktadır. Dağıtılmış(distributed) ağlar için sunulan eğitim teknikleri, büyük bir mini grubu bir makine kümesine paylaştırır ve sonra ortaya çıkan gradyanları toplar. Facebook yakın zamanda dağıtılmış eğitim yöntemlerini kullanarak bir saat içinde ImageNet verileri ile bir ağ eğitmiştir.

Gradyan İnişin tam boyutlu gruplar ile hiçbir zaman kullanılmaması gerektiğini belirtmek önemlidir. Tam toplu boyutta eğitim yapmak istiyorsak, LBFGS adlı bir optimizasyon tekniğini kullanırız. PyTorch ve SciPy'da bu tekniğin uygulamaları bulunmaktadır.

## [Momentum](https://www.youtube.com/watch?v=--NZb480zlg&t=1672s)

Momentum'da bir yerine iki tekrarlama ($p$ ve $w$) vardır. Güncellemeler aşağıdaki gibidir:

$$
\begin{aligned}
p_{k+1} &= \hat{\beta_k}p_k + \nabla f_i(w_k) \\
w_{k+1} &=  w_k - \gamma_kp_{k+1} \\
\end{aligned}
$$

$p$, SGD momentumu olarak adlandırılır. Her güncelleme adımında, stokastik gradyan $\beta$ çarpanıyla (0 ile 1 arasında bir değer) sönümlendikten sonra momentumun eski değerine eklenir. $p$ gradyanların sürekli hesaplanan ortalaması olarak düşünülebilir. Sonunda $w$ yeni momentum $p$ yönünde hareket ettirilir.

Alternatif Yapı: Stokastik Ağır Top Metodu

$$
\begin{aligned}
w_{k+1} &= w_k - \gamma_k\nabla f_i(w_k) + \beta_k(w_k - w_{k-1}) & 0 \leq \beta < 1
\end{aligned}
$$

Bu yapı, matematiksel olarak önceki yapıyla eşdeğerdir. Burada bir sonraki adım, önceki adımın yönünün ($w_k - w_ {k-1}$) ve yeni negatif gradyanın birleşimidir.

### Sezgisel Yaklaşım

SGD Momentum fizikteki momentum kavramına benzer. Optimizasyon süreci tepeden aşağı yuvarlanan ağır bir topa benzer. Momentum topu gittiği yönde devam edecek şekilde hareket ettirir. Gradyan ise topu başka bir yöne iten bir kuvvet olarak düşünülebilir.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/momentum.png"/><br>
<b>Şekil 3:</b> Momentumun Etkisi<br>
<b>Source:</b><a href="https://distill.pub/2017/momentum/" target="_blank"> distill.pub </a><br>
</center>

Momentum gidişat yönünde (soldaki şekilde olduğu gibi) etkili değişiklikler yapmak yerine, mütevazı değişiklikler yapar. Momentum tek başına SGD kullandığımızda çoğunlukla karşımıza çıkan salınımları sönümler.

$\beta$ parametresine Sönümleme Faktörü denir. $\beta$ sıfırdan büyük olmalıdır, sıfıra eşit olursa sadece gradyan inişi yapmış oluruz. Ayrıca 1'den küçük olmalıdır, aksi takdirde her şey patlar. $\beta$ 'nın daha küçük değerleri, yönün daha çabuk değişmesine neden olur. Daha büyük değerler için güncellemenin başka yöne dönmesi daha uzun sürer.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/momentum-beta.png" style="zoom: 40%; background-color:#DCDCDC;"/><br>
<b>Şekil 4:</b> Beta'nın Yakınsamadaki Etkisi
</center>


### Practical guidelines

Momentum must pretty much be always be used with stochastic gradient descent.
$\beta$ = 0.9 or 0.99 almost always works well.

The step size parameter usually needs to be decreased when the momentum parameter is increased to maintain convergence. If $\beta$ changes from 0.9 to 0.99, learning rate must be decreased by a factor of 10.


### Why does momentum works?


#### Acceleration

The following are the update rules for Nesterov's momentum.

$$
p_{k+1} = \hat{\beta_k}p_k + \nabla f_i(w_k) \\
w_{k+1} =  w_k - \gamma_k(\nabla f_i(w_k) +\hat{\beta_k}p_{k+1})
$$

With Nesterov's Momentum, you can get accelerated convergence if you choose the constants very carefully. But this applies only to convex problems and not to Neural Networks.

Many people say that normal momentum is also an accelerated method. But in reality, it is accelerated only for quadratics. Also, acceleration does not work well with SGD, as SGD has noise and acceleration does not work well with noise. Therefore, though some bit of acceleration is present with Momentum SGD, it alone is not a good explanation for the high performance of the technique.


#### Noise smoothing

Probably a more practical and probable reason to why momentum works is Noise Smoothing.

Momentum averages gradients. It is a running average of gradients that we use for each step update.

Theoretically, for SGD to work we should take average over all step updates.

$$
\bar w_k = \frac{1}{K} \sum_{k=1}^K w_k
$$

The great thing about SGD with momentum is that this averaging is no longer necessary. Momentum adds smoothing to the optimization process, which makes each update a good approximation to the solution. With SGD you would want to average a whole bunch of updates and then take a step in that direction.

Both Acceleration and Noise smoothing contribute to high performance of momentum.

<center>
<img src="{{site.baseurl}}/images/week05/05-1/sgd-vs-momentum.png" style="zoom: 35%; background-color:#DCDCDC;"/><br>
<b>Figure 5:</b> SGD vs Momentum
</center>

With SGD, we make good progress towards solution initially but when we reach bowl (bottom of the valley) we bounce around in this floor. If we adjust learning rate we will bounce around slower. With momentum we smooth out the steps, so that there is no bouncing around.
