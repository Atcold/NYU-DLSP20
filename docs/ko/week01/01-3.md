---
lang-ref: ch.01-3
title: 동기, 선형대수학 및 데이터 시각화
authors: Yunya Wang, SunJoo Park, Mark Estudillo, Justin Mae
# date:
lang: ko
translation-date: 25 Mar 2020
translator: Ryan
---

## 자료

트위터에서 알프레도 칸지아니 ([@alfcnz](https://twitter.com/alfcnz)) 를 팔로우하세요. 선형대수와 특이값 분해<sup>Singular Value Decomposition (SVD)</sup>를 다룬 영상들과 교과서는 트위터에서 검색할 수 있습니다. (예시: `linear algebra (from:alfcnz)`)


## [변환과 동기](https://www.youtube.com/watch?v=5_qrxVq1kvc&t=233s)

동기부여를 위해 이미지 분류 예시로 시작하자. 우리가 1 메가픽셀 카메라로 사진을 찍었다고 가정하자. 이 이미지는 약 1,000 화소의 높이와 1,000 화소의 너비를 가지고, 각 화소는 빨간색, 녹색, 파란색(RGB)의 세 가지 색 치수를 갖게 된다. 그렇다면 각각의 사진은 300만차원 공간에서 하나의 점으로 간주될 수 있다. 이렇게 거대한 차원수를 지닌 공간에서, 우리가 분류하고 싶은 많은 흥미로운 이미지들 - (예를 들어 개와 고양이)은 공간 안에서 거의 같은 영역에 있을 것이다.


In order to effectively separate these images, we consider ways of transforming the data in order to move the points. Recall that in 2-D space, a linear transformation is the same as matrix multiplication. For example, the following are linear transformations:

이러한 이미지를 효과적으로 분리하기 위해, 우리는 이러한 점들을 이동시키기 위해 데이터를 변환하는 방법을 고려한다. 기억할 점은, 2-D 공간에서 선형 변환은 행렬 곱셈과 동일하다는 것이다. 예를 들어, 다음은 선형 변환이다.

-   회전 (행렬이 직교행렬일 시).
-   크기 조정 (행렬이 대각행렬일 시).
-   선대칭 이동 (행렬식이 음수일 때).
-   깎기.

주목해야 할 것은, 강체 변환을 하면 0이 항상 0으로 매핑되지 않기 때문에, 이는 선형 변환이 아니고 아핀 변환이다. 다시 우리 예제로 돌아가서, 우리는 데이터 포인트를 변환하여 점들이 0 주위에 군집되도록 바꾸고, 대각선 행렬로 크기 조정을 함으로써 우리가 그 지역을 "확대"해서 볼 수 있도록 할 수 있다. 마지막으로, 우리는 종류가 다른 점들을 나누는 선을 발견함으로써 분류를 할 수 있다. 즉, 선형 변환과 비선형 변환을 사용하여 점을 선형적으로 분리할 수 있는 공간으로 매핑하는 것이다. 이 아이디어는 다음 섹션에서 더 자세히 다룰 것이다.


## [데이터 시각화 - 네트워크를 사용하여 색상별로 점 구분하기](https://www.youtube.com/watch?v=5_qrxVq1kvc&t=798s)

아래의 데이터 시각화에는 각기 다른 색을 가진 다섯 부분으로 나누어진 나선이 있다. 점들은 2차원 평면에 존재하며, 투플<sup>tuple</sup>로 나타낼 수 있고, 점들의 색은 각 점들의 종류를 나타내는 세 번째 차원을 나타낸다. 그 후 우리는 신경망을 사용하여 각각의 점들을 색상별로 구분한다.

| <center><img src="{{site.baseurl}}/images/week01/01-3/Spiral1.png" width="200px"/></center> | <center><img src="{{site.baseurl}}/images/week01/01-3/Spiral2.png" width="200px"/></center> |
|             (a) 입력되는 점들, 신경망 통과 전             |            (b) 출력된 점들, 신경망 통과 후             |

<center> 그림 1: 다섯 색의 나선 </center>
The network \"stretches\" the space fabric in order to separate each of the points into different subspaces. At convergence, the network separates each of the colours into different subspaces of the final manifold. In other words, each of the colours in this new space will be linearly separable using a one vs all regression. The vectors in the diagram can be represented by a five by two matrix; this matrix can be multiplied to each point to return scores for each of the five colours. Each of the points can then be classified by colour using their respective scores. Here, the output dimension is five, one for each of the colours, and the input dimension is two, one for the x and y coordinates of each of the points. To recap, this network basically takes the space fabric and performs a space transformation parametrised by several matrices and then by non-linearities.


### 신경망 구조

<center>
<img src="{{site.baseurl}}/images/week01/01-3/Network.png" style="zoom: 40%; background-color:#DCDCDC;" /><br>
그림 2: 신경망 구조
</center>

The first matrix maps the two dimensional input to a 100 dimensional intermediate hidden layer. We then have a non-linear layer, `ReLU` or Rectified Linear Unit, which is simply *positive part* $(\cdot)^+$ function. Next, to display our image in a graphical representation, we include an embedding layer that maps the 100 dimensional hidden layer input to a two-dimensional output. Lastly, the embedding layer is projected to the final, five-dimensional layer of the network, representing a score for each colour.


## [무작위 투영 - 주피터 노트북](https://www.youtube.com/watch?v=5_qrxVq1kvc&t=1693s)

The Jupyter Notebook can be found [here](https://github.com/Atcold/pytorch-Deep-Learning/blob/master/02-space_stretching.ipynb). In order to run the notebook, make sure you have the `pDL` environment installed as specified in [`README.md`](https://github.com/Atcold/pytorch-Deep-Learning/blob/master/README.md).


### 파이토치 `device`

PyTorch can run on both the CPU and GPU of a computer. The CPU is useful for sequential tasks, while the GPU is useful for parallel tasks. Before executing on our desired device, we first have to make sure our tensors and models are transferred to the device's memory. This can be done with the following two lines of code:

```python
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
X = torch.randn(n_points, 2).to(device)
```

The first line creates a variable, called `device`, that is assigned to the GPU if one is available; otherwise, it defaults to the CPU. In the next line, a tensor is created and sent to the device's memory by calling `.to(device)`.


### 주피터 노트북 팁

To see the documentation for a function in a notebook cell, use `Shift + Tab.`


### 선형 변환 시각화

Recall that a linear transformation can be represented as a matrix. Using singular value decomposition, we can decompose this matrix into three component matrices, each representing a different linear transformation.

$$
W = U\begin{bmatrix}s_1 & 0 \\ 0 & s_2 \end{bmatrix} V^\top
$$

In eq. (1), matrices $U$ and $V^\top$ are orthogonal and represent rotation and reflection transformations. The middle matrix is diagonal and represents a scaling transformation.

We visualize the linear transformations of several random matrices in Fig. 3. Note the effect of the singular values on the resulting transformations.

The matrices used were generated with Numpy; however, we can also use PyTorch's `nn.Linear` class with `bias = False` to create linear transformations.

| ![]({{site.baseurl}}/images/week01/01-3/initial_scatter_lab1.png) | ![]({{site.baseurl}}/images/week01/01-3/matrix_multiplication_lab1.png) | ![]({{site.baseurl}}/images/week01/01-3/matrix_multiplication_lab1_2.png) |
|     (a) 원본       |   (b) $s_1$ = 1.540, $s_2$ = 0.304  |   (c) $s_1$ = 0.464, $s_2$ = 0.017    |

<center> 그림 3: 무작위 행렬의 선형 변환 </center>


### 비선형 변환

Next, we visualize the following transformation:

$$
f(x) = \tanh\bigg(\begin{bmatrix} s & 0 \\ 0 & s \end{bmatrix} \bigg)
$$

Recall, the graph of $\tanh(\cdot)$ in Fig. 4.

<center>
<img src="{{site.baseurl}}/images/week01/01-3/tanh_lab1.png" width="250px" /><br>
Figure 4: hyperbolic tangent non-linearity
</center>

The effect of this non-linearity is to bound points between $-1$ and $+1$, creating a square. As the value of $s$ in eq. (2) increases, more and more points are pushed to the edge of the square. This is shown in Fig. 5. By forcing more points to the edge, we spread them out more and can then attempt to classify them.

| <img src="{{site.baseurl}}/images/week01/01-3/matrix_multiplication_with_nonlinearity_s=1_lab1.png" width="200px" /> | <img src="{{site.baseurl}}/images/week01/01-3/matrix_multiplication_with_nonlinearity_s=5_lab1.png" width="200px" /> |
|                 (a) Non-linearity with $s=1$                 |                 (b) Nonlinearity with $s=5$                  |

<center> Figure 5:   Non-linear Transformations </center>


### 무작위 신경망

Lastly, we visualize the transformation performed by a simple, untrained neural network. The network consists of a linear layer, which performs an affine transformation, followed by a hyperbolic tangent non-linearity, and finally another linear layer. Examining the transformation in Fig. 6, we see that it is unlike the linear and non-linear transformations seen earlier. Going forward, we will see how to make these transformations performed by neural networks useful for our end goal of classification.

<center>
<img src="{{site.baseurl}}/images/week01/01-3/untrained_nn_transformation_lab1.png" width="200px" /><br>
Figure 6:  Transformation from an untrained neural network
</center>
