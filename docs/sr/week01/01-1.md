---
lang: sr
lang-ref: ch.01-1
lecturer: Yann LeCun
title: Motivacija iza dubokog učenja, istorija i inspiracija
authors: Yunya Wang, SunJoo Park, Mark Estudillo, Justin Mae
date: 27 Jan 2020
translation-date: 13 Dec 2020
translator: Ema Pajić
---

<!-- Course plan
-->
## [Plan kursa](https://www.youtube.com/watch?v=0bMe_vCZo30&t=217s)

<!-- 
- Basics of Supervised Learning, Neural Nets, Deep Learning
- Backpropagation and architectural components
- Convolutional neural network and its applications
- More Deep Learning Architectures
- Regularization Tricks / Optimization Tricks / Understanding how Deep Learning works
- Energy-based models
- Self-supervised learning and beyond
-->
- Osnove nadgledanog učenja, Neuronske mreže, Duboko učenje
- Propagacija unazad i komponente arhitekture
- Konvolucione neuronske mreže i njihove primene
- Arhitekture dubokih neuronskih mreža
- Regularizacijski i optimizacijski trikovi / Razumevanje kako radi duboko učenje
- Modeli zasnovani na energiji
- Samonadgledano učenje


<!-- Inspiration of Deep Learning and its history
-->
## Inspiracija za duboko učenje i njegova istorija

<!-- On a conceptual level, deep learning is inspired by the brain but not all of the brain's details are relevant. For a comparison, aeroplanes were inspired by birds. The principle of flying is the same but the details are extremely different.
-->
Na konceptualnom nivou, duboko učenje je inspirisano mozgom, ali su neki detalji zanemareni. Kao poređenje, avioni su inspirisani pticama - princip letenja je isti, ali su detalji veoma različiti.

<!-- The history of deep learning goes back to a field which changed its name now to cybernetics. It started in the 1940s with McCulloch and Pitts. They came up with the idea that neurons are threshold units with on and off states. You could build a Boolean circuit by connecting neurons with each other and conduct logical inference with neurons. The brain is basically a logical inference machine because neurons are binary. Neurons compute a weighted sum of inputs and compare that sum to its threshold. It turns on if it's above the threshold and turns off if it's below, which is a simplified view of how neural networks work.
-->
Istorija dubokog učenja počinje sa oblašću nauke koja se trenutno zove kibernetika 1940-ih sa McCulloch-om i Pitts-om. Oni su došli na ideju da su neuroni jedinice koje mogu da budu u uključenom ili isključenom stanju i da postoji neki prag kada menjaju stanje. Moguće je napraviti Bulovo kolo (matematički model za kombinatorna digitalna logička kola) povezivanjem neurona i da se donose zaključci preko njih. Mozak je predstavljen kao mašina koja donosi zaključke preko neurona koji su binarni. Neuroni računaju težinsku sumu ulaza i porede je sa svojim pragom. Uključuju se ako je suma veća od praga, a isključuju ako je manja, što je uprošćen pogled na to kako mozak radi.

<!-- In 1947, Donald Hebb had the idea that neurons in the brain learn by modifying the strength of the connections between neurons. This is called hyper learning, where if two neurons are fired together, then the connection linked between them increases; if they don't fire together, then the connection decreases.
-->
1947., Donald Hebb je došao na ideju da mozak uči promenama jačine veza između neurona. To je nazvano hiperučenje: ako dva neurona ispale impuls zajedno, veza između njih se pojačava, u suprotnom slabi.

<!-- Later in 1948, cybernetics were proposed by Norbert Wiener, which is the idea that by having systems with sensors and actuators, you have a feedback loop and a self-regulatory system. The rules of the feedback mechanism of a car all come from this work.
-->
Kasnije u toku 1948., Norbert Wiener je predložio kibernetiku, što je ideja da postoje sistemi koji imaju senzore i aktuatore, povratnu spregu i samoregulišući sistem. Pravila povratnog mehanizma automobila dolaze iz ovog rada.

<!-- In 1957, Frank Rosenblatt proposed the Perceptron, which is a learning algorithm that modifies the weights of very simple neural nets.
-->
1957., Frank Rosenblatt je osmislio perceptron, algoritam koji modifikuje težine veoma jednostavnih neuronskih mreža.

<!-- Overall, this idea of trying to build intellectual machines by simulating lots of neurons was born in 1940s, took off in 1950s, and completely died in late 1960s. The main reasons for the field dying off in 1960 are:
-->
Ideja da se naprave inteligentne mašine simulacijom velikog broja neurona nastala je 1940-ih, razvijala se tokom 1950-ih, i kompletno je napuštena krajem 1960-ih. Glavni razlozi za napuštanje ove ideje 1960-ih su:

<!-- - The researchers used neurons that were binary. However, the way to get backpropagation to work is to use activation functions that are continuous. At that time, researchers didn't have the idea of using continuous neurons and they didn't think they can train with gradients because binary neurons are not differential.
- With continuous neurons, one would have to multiply the activation of a neuron by a weight to get a contribution to the weighted sum. However, before 1980, the multiplication of two numbers, especially floating-point numbers, were extremely slow. This resulted in another incentive to avoid using continuous neurons.
-->
- Naučnici su koristili neurone koji su binarni. Međutim, da bi propagacija unazad radila, aktivacione funkcije su morale da budu neprekidne. U to vreme, naučnici nisu došli do ideje da upotrebe neprekidne neurone i nisu mislili da je moguće da se obučava preko gradijenata jer binarni neuroni nisu diferencijabilni.
- Kod neprekidnih neurona, aktivaciju neurona treba pomnožiti težinom da bi se dobio doprinos težinskoj sumi. Međutim, pre 1980-te, množenje dva broja, pogotovu decimalnih brojeva je bilo veoma sporo. To je bio još jedan razlog da se izbegne upotreba neprekidnih neurona.

<!-- Deep Learning took off again in 1985 with the emergence of backpropagation. In 1995, the field died again and the machine learning community abandoned the idea of neural nets. In early 2010, people start using neuron nets in speech recognition with huge performance improvement and later it became widely deployed in the commercial field. In 2013, computer vision started to switch to neuron nets. In 2016, the same transition occurred in natural language processing. Soon, similar revolutions will occur in robotics, control, and many other fields.
-->
Duboko učenje je nastavilo da se razvija 1985. sa pojavom propagacije unazad. 1995., oblast je ponovo pala u zaborav i napuštena je ideja neuronskih mreža. Početkom 2010-ih, neuronske mreže su upotrebljene u prepoznavanju govora i postigle veliko poboljšanje performansi, a zatim se upotreba veoma raširila. 2013-te, računarska vizija je počela da većinski koristi neuronske mreže. 2016-te, isto se desilo i sa obradom prirodnih jezika. Uskoro će se slične revolucije desiti i u robotici, automatskom upravljanju i mnogim drugim oblastima.

<!-- Supervised learning 
-->
### Nadgledano učenje

<!-- $90\%$ of deep learning applications use supervised learning. Supervised learning is a process by which, you collect a bunch of pairs of inputs and outputs, and the inputs are feed into a machine to learn the correct output. When the output is correct, you don't do anything. If the output is wrong, you tweak the parameter of the machine and correct the output toward the one you want. The trick here is how you figure out which direction and how much you tweak the parameter and this goes back to gradient calculation and backpropagation.
-->
$90\%$ primena dubokog učenja koriste nadgledano učenje. Nadgledano učenje je proces gde se mreži da veliki broj parova ulaza i izlaza iz kojih treba da nauči kako da za novi dati ulaz predvidi tačan izlaz. U procesu obučavanja, kada je izlaz tačan, ne radi se ništa. Ako je izlaz netačan, malo se promene parametri mreže i ispravi izlaz ka onome koji želimo. Trik je znati u kom smeru i koliko promeniti parametre - i to nas dovodi do računanja gradijenata i propagacije unazad.

<!-- Supervised learning stems from Perceptron and Adaline. The Adaline is based on the same architecture with weighted inputs; when it is above the threshold, it turns on and below the threshold, it turns off. The Perceptron is a 2-layer neuron net where the second layer is trainable and the first layer is fixed. Most of the time, the first layer is determined randomly and that's what they call associative layers.
-->
Nadgledano učenje potiče od perceptrona i Adaline. Adaline mreža je bazirana na istoj arhitekturi sa težinskim ulazima - iznad praga se uključuje, a ispod isključuje. Perceptron je neuronska mreža sa 2 sloja. Drugi sloj se obučava, a prvi sloj je fiksiran. Uglavnom, prvi sloj je određen nasumično i zove se asocijativni sloj.

<!-- History of Pattern Recognition and introduction to Gradient Descent
-->
## [Istorija prepoznavanja oblika i uvod u gradijentni spust](https://www.youtube.com/watch?v=0bMe_vCZo30&t=1461s)

<!-- The foregoing is the conceptual basis of pattern recognition before deep learning developed. The standard model of pattern recognition consists of feature extractor and trainable classifier. Input goes into the feature extractor, extracting relevant useful characteristics of inputs such as detecting an eye when the purpose is recognizing the face. Then, the vector of features is fed to the trainable classifier for computing weighted sum and comparing it with the threshold. Here, a trainable classifier could be a perceptron or single neural network. The problem is feature extractor should be engineered by hand. Which means, pattern recognition/computer vision focus on feature extractor considering how to design it for a particular problem, not much devoted to a trainable classifier.
-->
U nastavku su opisane konceptualne osnove prepoznavanja oblika pre razvoja dubokog učenja. Standardan model za prepoznavanje oblika ima deo koji izvlači obeležja i klasifikator koji se obučava. Ulaznim podacima se prvo izvlače obeležja - relevantne korisne karakteristike ulaza, kao na primer detektovano oko ako je cilj prepoznati lice. Nakon toga, vektor obeležja se prosleđuje klasifikatoru koji računa težinske sume i poredi sa pragom. Klasifikator koji obučavamo može da bude perceptron ili neuronska mreža. Problem je što odluku koja obeležja izvlačimo mora da napravi čovek. To znači da se prepoznavanje oblika / računarska vizija fokusirala na izvlačenje odlika i njihov dizajn za specifičan problem, a klasifikatoru se nije posvećivalo puno vremena.

<!-- After the emergence and development of deep learning, the 2-stage process changed to the sequences of modules. Each module has tunable parameters and nonlinearity. Then, stack them making multiple layers. This is why it is called “deep learning”. The reason why using nonlinearity rather than linearity is that two linear layers could be one linear layer since the composition of two linear is linear.
-->
Nakon pojave i razvoja dubokog učenja, umesto ova 2 dela počela je da se koristi sekvenca modula. Svaki modul ima podesive parametre i nelinearnost. Takva sekvenca modula čini više slojeva i zato se ova oblast i zove duboko učenje. Razlog za korišćenje nelinearnosti umesto linearnosti je to što dva linearna sloja mogu da budu jedan linearan sloj jer je kompozicija dva linearna sloja linearna.

<!-- The simplest multi-layer architecture with tunable parameters and nonlinearity could be: input is represented as a vector such as an image or audio. This input is multiplied by the weight matrix which coefficient is a tunable parameter. Then, every component of the result vector is passed through a nonlinear function such as ReLU. Repeating this process, it becomes a basic neural network. The reason why it is called a neural network is that this architecture calculates the weighted sum of components of input by corresponding rows of a matrix.
-->
Najjednostavnija višeslojna arhitektura sa podesivim parametrima i nelinearnošću može da bude: ulaz (recimo slika ili audio) je predstavljen kao vektor. Ulaz se pomnoži matricom težina čiji koeficijenti su podesivi. Zatim, svaka komponenta vektora rezultata se prosledi nelinearnoj funkciji kao što je ReLU. Ponavljajući taj proces, dobijamo običnu neuronsku mrežu. Razlog zašto se zove neuronska mreža je to što ova arhitektura računa težinsku sumu komponenti ulaza sa odgovarajućim redovima matrice.

<!-- Back to the point of supervised learning, we are comparing the resulting output with target output then optimize the objective function which is loss computing distance/penalty/divergence between the result and target. Then, average this cost function over the training set. This is the goal we want to minimize. In other words, we want to find the value of the parameters that minimize this average.
-->
Da se vratimo na smisao nadgledanog učena, poredimo izlaz koji vraća neuronska mreža sa ciljanim izlazima i optimizujemo funkciju gubitka, koja računa rastojanje / kaznu / divergenciju između dobijenog i ciljanog rezultata. Zatim, usrednjujemo ovu funkciju cene po obučavajućem skupu podataka. To je vrednost koju želimo da minimizujemo. Drugim rečima, želimo da nađemo vrednosti parametara koje minimizuju prosečnu grešku na obučavajućem skupu.

<!-- The method of how to find it is computing gradient. For example, if we are lost in a smooth mountain at foggy night and want to go to the village in the valley. One way could be turning around and seeing which way the steepest way is to go down then take a small step down. The direction is (negative) gradient. With the assumption that the valley is convex, we could reach the valley.
-->
Način kako da nađemo željene parametre je računanjem gradijenata. Na primer, ako zamislimo da smo se izgubili na planini u maglovitoj noći i želimo da se spustimo do sela koje se nalazi u uvali, jedan način bi bio da se okrenemo oko sebe i pronađemo najstrmiji put dole i zakoračimo u tom smeru. Taj smer je (negativni) gradijent. Sa pretpostavkom da je uvala konveksna, mogli bismo da stignemo do sela.

<!-- The more efficient way is called Stochastic Gradient Descent (SGD). Since we want to minimize average loss over the training set, we take one sample or small group of samples and calculate the error, then use gradient descent. Then, we take a new sample and get a new value for the error, then get the gradient which is a different direction normally. Two of the main reasons for using SGD are that it helps a model to converge fast empirically if the training set is very large and it enables better generalization, which means getting similar performance on various sets of data.
-->
Efikasniji način se zove stohastički gradijentni spust (SGD). Pošto želimo da minimizujemo prosečni gubitak na obučavajućem skupu, uzmemo jedan odbirak ili malu grupu odbiraka i izračunamo grešku, zatim primenimo gradijentni spust. Zatim uzmemo novi odbirak i dobijemo novu vrednost za grešku, zatim gradijent koji je obično u drugom smeru. Dva glavna razloga za korišćenje stohastičkog gradijentnog spusta su to što pomaže modelu da brže konvergra empirijski ako je obučavajući skup veoma veliki i omogućava bolju generalizaciju, što znači dobijanje sličnih performansi na različitim skupovima podataka.

<!-- Computing gradients by backpropagation
-->
### [Računanje gradijenata propagacijom unazad](https://www.youtube.com/watch?v=0bMe_vCZo30&t=2336s)

<!-- Computing gradients by backpropagation is a practical application of the chain rule. The backpropagation equation for the input gradients is as follows:
-->
Računanje gradijenata propagacijom unazad je praktična primena lančanog pravila. Jednačina propagacije unazad za ulazne gradijente je:

$$
\begin{aligned}
\frac{\partial C}{\partial \boldsymbol{x}_{i - 1}} &= \frac{\partial C}{\partial \boldsymbol{x}_i}\frac{\partial \boldsymbol{x}_i}{\partial \boldsymbol{x}_{i - 1}} \\
\frac{\partial C}{\partial \boldsymbol{x}_{i - 1}} &= \frac{\partial C}{\partial \boldsymbol{x}_i}\frac{\partial f_i(\boldsymbol{x}_{i - 1}, \boldsymbol{w}_i)}{\partial \boldsymbol{x}_{i - 1}}
\end{aligned}
$$

<!-- The backpropagation equation for the weight gradients is as follows:
-->
Jednačina propagacije unazad za težinske gradijente je:

$$
\begin{aligned}
\frac{\partial C}{\partial \boldsymbol{w}_{i}} &= \frac{\partial C}{\partial \boldsymbol{x}_i}\frac{\partial \boldsymbol{x}_i}{\partial \boldsymbol{w}_{i}} \\
\frac{\partial C}{\partial \boldsymbol{w}_{i}} &= \frac{\partial C}{\partial \boldsymbol{x}_i}\frac{\partial f_i(\boldsymbol{x}_{i - 1}, \boldsymbol{w}_i)}{\partial \boldsymbol{w}_{i}}
\end{aligned}
$$

<!-- Note that instead of scalar inputs, they will be vector inputs. More generally, multi-dimensional inputs. Backpropagation allows you to compute the derivative of the difference of the output you want and the output you get (which is the value of the objective function) with respect to any value inside the network. Finally, backpropagation is essential as it applies to multiple layers.
-->
Napomena: umesto skalarnih ulaza, ulazi će biti vektori - uopštenije, multidimenzionalni ulazi. Propagacija unazad omogućava računanje izvoda razlike izlaza koji želimo i koji smo dobili (funkcije gubitka) po bilo kojoj vrednosti u mreži. Na kraju, propagacija unazad je neophodna jer se primenjuje na više slojeva.

<!-- It is important to consider how to interpret inputs. For example, an image of 256$$\times$$256 would require a 200,000 valued matrix. These would be huge matrices that the neural network layers will need to handle. It would be impractical to utilize such matrices. Therefore, it is important to make hypothesis of the structure of the matrix.
-->
Bitno je razmotriti kako da se interpretiraju ulazi. Na primer, slika 256$$\times$$256 bi zahtevala matricu sa 200,000 vrednosti. To bi bile ogromne matrice koje bi mreža morala da koristi i bilo bi nepraktično koristiti ih. Iz tog razloga, bitno je pretpostaviti strukturu matrice.

<!-- Hierarchical representation of the Visual Cortex
-->
## Hijerarhijska reprezentacija vizuelnog korteksa

<!-- Experiments by Fukushima gave us an understanding of how our brain interprets the input to our eyes. In summary, it was discovered that neurons in front of our retina compress the input (known as contrast normalization) and the signal travels from our eyes to our brain. After this, the image gets processed in stages and certain neurons get activated for certain categories. Hence, the visual cortex does pattern recognition in a hierarchical manner.
-->
Eksperimenti koje je radio Fukušima doveli su do razumevanja kako mozak interpretira ono što oči vide. Ukratko, otkriveno je da neuroni na početku retine kompresuju ulaz (ovo je poznato kao normalizacija kontrasta) i signal putuje od naših očiju do mozga. Zatim, slika se procesira u fazama i određeni neuroni se aktiviraju za određene kategorije. Dakle, vizuelni korteks radi prepoznavanje oblika hijerarhijski.

<!-- Experiments in which researchers poked electrodes in specific areas of the visual cortex, specifically the V1 area made researchers realize that certain neurons react to motifs that appear in a very small area in a visual field and similarly with neighbouring neurons and neighbouring areas in the visual field. Additionally, neurons that react to the same visual field, react to different types of edges in an organized manner (e.g. vertical or horizontal edges). It is also important to note that there's also the idea that the visual process is essentially a feed forward process. Hence, somehow fast recognition can be done without some recurrent connections.
-->
Eksperimenti u kojima su naučnici postavljali elektrode u specifične regije vizuelnog korteksa, specifično V1 regija, doveli su do zaključka da određeni neuroni reaguju na motive koji se pojavljuju u veoma maloj površini vidnog polja i da susedni neuroni vide bliske delove vidnog polja.
Dodatno, neuroni koji reaguju na isti deo vidnog polja, reaguju na različite tipove ivica (na primer, vertikalne ili horizontalne ivice). Takođe, u nauci je većinom prihvaćena ideja da je vizuelni proces direktan, unapred propagiran proces. Dakle, donekle brzo prepoznavanje se može uraditi bez rekurentnih konekcija.

